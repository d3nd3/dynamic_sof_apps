//*******************************************
// Menu Store - Client-side Receiver (.func)
//
// Listens for server-sent chunks on _sp_cl_sv_dl and assembles to disk.
// Writes a temporary .cfg that defines global cvars and can be exec'ed.
//
// Server sends:
//   _sp_cl_sv_dl_info: <type> <name> <totalLen> <chunkSize>
//   _sp_cl_sv_dl: chunk data
//   _sp_cl_sv_dl_done: set to 1 when finished
//
// This receiver stores into:
//   _ms_rx_type, _ms_rx_name, _ms_rx_total, _ms_rx_chunk, _ms_rx_buf
//   _ms_rx_pos, _ms_rx_ready
// And progress cvar:
//   _ms_rx_progress (0..100)
//
// After completion, it writes user/menus/_ms_install_<name>.cfg and
// then exec's it if auto-exec is enabled.
//

function ms_transport_client_init( )
{
  set _ms_rx_pos 0
  set _ms_rx_total 0
  set _ms_rx_ready 0
  set _ms_rx_autoexec 1
  set _ms_rx_progress 0

  // React to incoming info/parts/done
  sp_sc_on_change _sp_cl_sv_dl_info ms_rx_on_info
  sp_sc_on_change _sp_cl_sv_dl ms_rx_on_part
  sp_sc_on_change _sp_cl_sv_dl_done ms_rx_on_done
}

function ms_rx_on_info( * )
{
  // Expected: <type> <name> <total> <chunk>
  sp_sc_cvar_split text _sp_cl_sv_dl_info _ms_rx_type _ms_rx_name _ms_rx_total _ms_rx_chunk
  set _ms_rx_first 1
  set _ms_rx_pos 0
  set _ms_rx_ready 0
  set _ms_rx_progress 0

  // ACK back to the server using a dot-command
  dot_MSACK
}

function ms_rx_on_part( * )
{
  // First chunk carries header; strip before execute
  sp_sc_flow_if number cvar _ms_rx_first == val 1
  {
    sp_sc_cvar_substr ~hdr _sp_cl_sv_dl 0 5
    sp_sc_flow_if text cvar ~hdr == val FFFFf
    {
      sp_sc_cvar_len ~len _sp_cl_sv_dl
      sp_sc_cvar_math_sub ~payloadLen #~len 5
      sp_sc_cvar_substr ~payload _sp_cl_sv_dl 5 #~payloadLen
      set _ms_rx_first 0
      // Unescape before executing
      sp_sc_cvar_unescape ~payload ~payload
      sp_sc_exec_cvar ~payload
      set ~clen #~payloadLen
    }
    else
    {
      sp_sc_flow_if text cvar ~hdr == val FFFFr
      {
        sp_sc_cvar_len ~len _sp_cl_sv_dl
        sp_sc_cvar_math_sub ~payloadLen #~len 5
        sp_sc_cvar_substr ~payload _sp_cl_sv_dl 5 #~payloadLen
        set _ms_rx_first 0
        // For RMF, write to disk; let caller decide when to open
        sset ~file menus/_ms_install_ #_ms_rx_name .rmf
        // Unescape before saving
        sp_sc_cvar_unescape ~payload ~payload
        sp_sc_cvar_save #~file ~payload
        set ~clen #~payloadLen
      }
      else
      {
        // Unknown header; treat as raw
        set _ms_rx_first 0
        sp_sc_exec_cvar _sp_cl_sv_dl
        sp_sc_cvar_len ~clen _sp_cl_sv_dl
      }
    }
  }
  else
  {
    sp_sc_exec_cvar _sp_cl_sv_dl
    sp_sc_cvar_len ~clen _sp_cl_sv_dl
  }

  // Update position by chunk length
  sp_sc_cvar_math_add _ms_rx_pos #~clen

  // Update progress
  sp_sc_flow_if number cvar _ms_rx_total > val 0
  {
    set ~pct 0
    sp_sc_cvar_math_mul ~pct #_ms_rx_pos 100
    sp_sc_cvar_math_div ~pct #_ms_rx_total
    set _ms_rx_progress #~pct
  }
}

function ms_rx_on_done( * )
{
  sp_sc_flow_if number cvar _sp_cl_sv_dl_done == val 1
  {
    set _ms_rx_ready 1
    sp_sc_func_exec ms_rx_finalize
  }
}

function ms_rx_finalize( * )
{
  // Chunks were executed as they arrived; if the incoming stream creates
  // or fills local cvars and saves them, they are ready now.
  // Nothing else required here by default.
}


