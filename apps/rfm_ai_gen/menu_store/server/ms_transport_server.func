//*******************************************
// Menu Store - Server-side Transport (.func)
//
// Sends converted menu/function data to a client using
// sp_sv_client_cvar_set in controlled 100ms chunks.
//
// Usage (server):
//   set _ms_tx_slot <clientSlot>
//   set _ms_tx_type func // or rmf
//   set _ms_tx_name <fileBaseName>
//   set _ms_tx_data <ENTIRE_ENCODED_SCRIPT_STRING>
//   sp_sc_func_exec ms_tx_init
//   sp_sc_func_exec ms_tx_begin
//
// Configurable:
//   _ms_tx_chunk_size (default 64)
//   _ms_tx_timer_ms   (default 100)
//

function ms_transport_server_init( )
{
  sp_sc_flow_if text cvar _ms_tx_chunk_size == val "" 
  {
    set _ms_tx_chunk_size 64
  }

  sp_sc_flow_if text cvar _ms_tx_timer_ms == val ""
  {
    set _ms_tx_timer_ms 100
  }

  echo "ms_transport_server_init: _ms_tx_chunk_size = #_ms_tx_chunk_size, _ms_tx_timer_ms = #_ms_tx_timer_ms"
}

// Begin a new transmission. Expects:
// _ms_tx_slot, _ms_tx_type ("rmf"|"func"), _ms_tx_name, _ms_tx_data
function ms_tx_begin( * )
{
  // Validate payload length pre/post escape using short cvar name (~p)
  set _ms_tx_can_send 1
  set ~p #_ms_tx_data

  // Pre-escape length: payload + 45 chars safety budget (header/overhead)
  sp_sc_cvar_len ~lpre ~p
  set ~lpre_line #~lpre
  sp_sc_cvar_math_add ~lpre_line 45
  sp_sc_flow_if number cvar ~lpre_line > val 255
  {
    sp_sv_print_client #_ms_tx_slot "MenuStore: payload too long pre-escape (>255)."
    set _ms_tx_can_send 0
  }

  // Escape in place
  sp_sc_cvar_escape ~p ~p

  // Post-escape length: escaped payload + 45 chars safety budget (header/overhead)
  sp_sc_cvar_len ~lpost ~p
  set ~lpost_line #~lpost
  sp_sc_cvar_math_add ~lpost_line 45
  sp_sc_flow_if number cvar ~lpost_line > val 255
  {
    sp_sv_print_client #_ms_tx_slot "MenuStore: payload too long post-escape (>255)."
    set _ms_tx_can_send 0
  }

  // Proceed only if checks passed
  sp_sc_flow_if number cvar _ms_tx_can_send == val 1
  {
    // Prepend tiny header: "FFFF" + 1-byte type marker (ascii)
    // Note: header is textual to stay network-safe.
    set _ms_tx_type_char f
    sp_sc_flow_if text cvar _ms_tx_type == val rmf
    {
      set _ms_tx_type_char r
    }
    sp_sc_cvar_sset _ms_tx_header "FFFF" #_ms_tx_type_char
    sp_sc_cvar_sset _ms_tx_send #_ms_tx_header #~p

    sp_sc_cvar_len _ms_tx_len _ms_tx_send
    set _ms_tx_pos 0

    // Send meta to the client: <type> <name> <totalLen> <chunkSize>
    sset _ms_tx_info #_ms_tx_type #_ms_tx_name #_ms_tx_len #_ms_tx_chunk_size
    sp_sv_client_cvar_set #_ms_tx_slot _sp_cl_sv_dl_info #_ms_tx_info
    // Wait for client ACK (via .MSACK) before starting data stream
    set _ms_tx_wait_ack 1
  }
}

// Internal: send next chunk and reschedule until done
function ms_tx_step( * )
{
  set ~remain #_ms_tx_len
  sp_sc_cvar_math_sub ~remain #_ms_tx_pos

  sp_sc_flow_if number cvar ~remain <= val 0
  {
    sp_sv_client_cvar_set #_ms_tx_slot _sp_cl_sv_dl_done 1
  }
  else
  {
    set ~n #_ms_tx_chunk_size
    // Hard clamp to 250 to stay under 255-char cvar limit
    sp_sc_flow_if number cvar ~n > val 250
    {
      set ~n 250
    }
    sp_sc_flow_if number cvar ~n > cvar ~remain
    {
      set ~n #~remain
    }

    sp_sc_cvar_substr ~chunk _ms_tx_send #_ms_tx_pos #~n
    sp_sv_client_cvar_set #_ms_tx_slot _sp_cl_sv_dl #~chunk

    sp_sc_cvar_math_add _ms_tx_pos #~n
    sp_sc_timer #_ms_tx_timer_ms "sp_sc_func_exec ms_tx_step"
  }
}

// Client acknowledges meta reception using a dot-command. Start streaming then.
function .MSACK( * )
{
  sp_sc_flow_if number cvar _ms_tx_wait_ack == val 1
  {
    set _ms_tx_wait_ack 0
    sp_sc_func_exec ms_tx_step
  }
}


